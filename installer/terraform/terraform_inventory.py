#!/usr/bin/env python
#

"""
Dynamic inventory for Terraform - finds all `.tfstate` files below the working
directory and generates an inventory based on their contents.

Credit where credit's due - this code was adapted from Cisco's
terraform.py plugin (https://github.com/CiscoCloud/terraform.py/tree/master/LICENSE).

Thanks, guys, it's been immensely useful.
"""

from __future__ import unicode_literals, print_function
import argparse
from collections import defaultdict
import json
import os

VERSION = "0.2.0"

DEFAULT_ROOT = os.path.abspath(
    os.path.dirname(__file__)
)


def get_state_files(root):
    """
    Enumerate all terraform state files under the root directory.

    :param root: The root directory.
    """
    for dirpath, _, filenames in os.walk(root):
        for name in filenames:
            if os.path.splitext(name)[-1] == ".tfstate":
                yield os.path.join(dirpath, name)


def get_resources(filenames):
    """
    Enumerate all terraform resources data (name, key, resource) in the specified Terraform state files.

    :param filenames: The state file names.
    """
    for filename in filenames:
        with open(filename, "r") as json_file:
            state = json.load(json_file)
            for module in state["modules"]:
                name = module["path"][-1]
                for key, resource in module["resources"].items():
                    yield name, key, resource


def get_hosts(resources):
    """
    Parse host data from resources.

    :param resources: The Terraform resource state data.

    :returns: A sequence of host data.
    """
    for _, key, resource in resources:
        resource_type, _ = key.split(".", 1)
        if resource_type != "ddcloud_server":
            continue

        yield parse_ddcloud_server(resource)


def _parse_prefix(source, prefix, sep="."):
    for compkey, value in source.items():
        try:
            curprefix, rest = compkey.split(sep, 1)
        except ValueError:
            continue

        if curprefix != prefix or rest == "#":
            continue

        yield rest, value


def parse_attr_list(source, prefix, sep="."):
    attrs = defaultdict(dict)
    for compkey, value in _parse_prefix(source, prefix, sep):
        idx, key = compkey.split(sep, 1)
        attrs[idx][key] = value

    return attrs.values()


def parse_dict(source, prefix, sep="."):
    return dict(_parse_prefix(source, prefix, sep))


def parse_list(source, prefix, sep="."):
    return [value for _, value in _parse_prefix(source, prefix, sep)]


def parse_ddcloud_server(resource):
    raw_attrs = resource["primary"]["attributes"]
    name = raw_attrs.get("name")
    groups = []

    tags = {}
    raw_tags = parse_attr_list(raw_attrs, "tag")
    for raw_tag in raw_tags:
        tags[raw_tag["name"]] = raw_tag["value"]

    attrs = {
        "id": raw_attrs["id"],
        "name": raw_attrs["name"],

        # Use private IPv4 address by default.
        "primary_ip": raw_attrs["primary_adapter_ipv4"],

        "private_ipv4": raw_attrs["primary_adapter_ipv4"],
        "public_ipv4": raw_attrs["public_ipv4"],
        "tags": tags,
        "provider": "ddcloud",

        # Use public IPv4 address for SSH, though.
        "ansible_ssh_host": tags.get(
            "ansible_ssh_host",
            raw_attrs["public_ipv4"]
        ),
        "ansible_ssh_port": int(tags.get("ansible_ssh_port", "22")),
        "ansible_ssh_user": tags.get("ansible_ssh_user", "root"),
    }

    attrs.update({
        "roles": attrs["tags"].get("roles", "none").split(",")
    })

    for role in attrs["roles"]:
        groups.append(role)

    return name, attrs, groups


# Inventory plugin queries


def query_host(hosts, target):
    for name, attrs, _ in hosts:
        if name == target:
            return attrs

    return {}


def query_list(hosts):
    groups = defaultdict(dict)
    meta = {}

    for name, attrs, hostgroups in hosts:
        for group in set(hostgroups):
            groups[group].setdefault("hosts", [])
            groups[group]["hosts"].append(name)

        meta[name] = attrs

    groups["_meta"] = {"hostvars": meta}
    return groups


def query_hostfile(hosts):
    out = ["## begin hosts generated by ceph-terraform-inventory.py ##"]
    out.extend(
        "{}\t{}".format(attrs["ansible_ssh_host"].ljust(16), name)
        for name, attrs, _ in hosts
    )

    out.append("## end hosts generated by ceph-terraform-inventory.py ##")
    return "\n".join(out)


def main():
    parser = argparse.ArgumentParser(
        __file__, __doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    modes = parser.add_mutually_exclusive_group(required=True)
    modes.add_argument("--list",
                       action="store_true",
                       help="list all variables")
    modes.add_argument("--host", help="list variables for a single host")
    modes.add_argument("--version",
                       action="store_true",
                       help="print version and exit")
    modes.add_argument("--hostfile",
                       action="store_true",
                       help="print hosts as a /etc/hosts snippet")
    parser.add_argument("--pretty",
                        action="store_true",
                        help="pretty-print output JSON")
    parser.add_argument("--nometa",
                        action="store_true",
                        help="with --list, exclude hostvars")
    parser.add_argument("--root",
                        default=DEFAULT_ROOT,
                        help="custom root to search for .tfstate files")

    args = parser.parse_args()

    if args.version:
        print("%s %s" % (__file__, VERSION))
        parser.exit()

    hosts = get_hosts(get_resources(
        get_state_files(args.root)
    ))
    if args.list:
        output = query_list(hosts)
        if args.nometa:
            del output["_meta"]
        print(json.dumps(output, indent=4 if args.pretty else None))
    elif args.host:
        output = query_host(hosts, args.host)
        print(json.dumps(output, indent=4 if args.pretty else None))
    elif args.hostfile:
        output = query_hostfile(hosts)
        print(output)

    parser.exit()


if __name__ == "__main__":
    main()
